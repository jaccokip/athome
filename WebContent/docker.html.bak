<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame
	Remove this if you use the .htaccess -->
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

	<title>Docker</title>
	<meta name="description" content="">
	<meta name="author" content="jacco" >
	<link rel="icon" href="favicon.ico">
	<link rel="stylesheet" type="text/css" href="css/menu.css">
	<link rel="stylesheet" type="text/css" href="css/sober.css">
	<link rel="stylesheet" type="text/css" href="css/sober.css" title="Default">
	<link rel="alternate stylesheet" type="text/css" href="css/pinned_menu.css" title="pinned">
	
	<link rel="stylesheet" type="text/css" href="css/sober.css" title="clean" />
	<link rel="alternate stylesheet" type="text/css" href="css/nmap.css" title="nmap">
	<link rel="alternate stylesheet" type="text/css" href="css/com_back.css" title="grey">
	
	<!--	<script src="scripts/nomouse.js"></script> -->
	<script type="text/javascript" src="scripts/jquery-1.11.2.js"></script>
	<script type="text/javascript" src="scripts/col-test.js"></script>
	
	<script src="scripts/swapstyle.js"></script>
	<script type="text/javascript">
	if( self != top ) { document.write('<style type="text/css">\n#backlinks { display: none; }\n<\/style>'); }
	</script>
	
	<meta name="viewport" content="width=device-width; initial-scale=1.0">

	<!-- Replace favicon.ico & apple-touch-icon.png in the root of your domain and delete these references 
		<link rel="shortcut icon" href="/favicon.ico">
		<link rel="apple-touch-icon" href="/apple-touch-icon.png"> -->
	<!--[if IE]><link rel="shortcut icon" href="path/to/favicon.ico"><![endif]-->
<!--
	<link rel="icon" href="path/to/favicon.png">
	<link rel="apple-touch-icon-precomposed" href="apple-touch-icon-precomposed.png">

-->

</head>

<body>
	
<header>
	<div>		
		<nav>
			<ul>
				<li><img id="in_out" onclick="changeStyle('pinned')" src="images/Pin.png" width="30" height="30"></a></li>
				<li><a href="index.html">Home</a>
					<ul>
						<li><a href="styles.html">Styles</a>
							<ul>
								<li><a href="#" onClick="changeStyle('grey');">cmd-line</a></li>
								<li><a href="#" onClick="changeStyle('stars');">stars</a></li>
								<!-- <li><a href="#" onClick="changeStyle('python');">python</a></li>
								<li><a href="#" onClick="changeStyle('tcpdump');">tcpdump</a></li>
								<li><a href="#" onClick="changeStyle('nmap');">nmap</a></li> -->
								<li><a href="#" onClick="changeStyle('Default');">Reset to default</a></li>
							</ul>
						</li>
					</ul>
				</li>
		<li><a href="index.html">Naslag_OS <span class="caret"></span></a>
			<ul>
				<li><a href="linux_commands.html">Commands</a></li>
				<li><a href="tcpdump.html">Tcpdump</a></li>
				<li><a href="nmap.html">Nmap</a></li>
				<li><a href="vim.html">Vim</a></li>
			</ul>
		</li>
		<li><a href="index.html">Naslag<span class="caret"></span></a>
			<ul>
				<li><a href="cat_api.html">Elasticsearch</a></li>
     <li><a href="docker.html">Docker</a></li>
				<li><a href="Escape_code.html">Escape characters</a></li>
				<li><a href="git.html#table">Git</a></li>
				<li><a href="python.html">Python</a>
					<ul>
						<li><a href="python_examples.html">Examples</a></li>
					</ul>
				</li>
				<li><a href="puppet.html">Puppet</a>
					<ul>
						<li><a href="puppet_training.html">Puppet_Training</a></li>
					</ul>
				</li>
			</ul>
		</li>
		<li><a href="url_naar.html">Off Site</a>

			<ul>
				<li><a href="http://www.apache.org/" target="_blank">apache</a>
					<ul>
						<li><a href="http://httpd.apache.org/docs/2.0/misc/rewriteguide.html" target="_blank">rewrite</a></li>
						<li><a href="https://www.addedbytes.com/articles/for-beginners/url-rewriting-for-beginners/" target="_blank">rewrite_dummies </a></li>
					</ul>
				</li>
				<li><a href="http://www.ibm.com">IBM</a>
					<ul>
						<li><a href="http://www.ibm.com/developerworks" target="_blank">developers</a></li>
					</ul>
				</li>
				<li><a href="http://nl.wikipedia.org/wiki/HyperText_Markup_Language">HTML</a>
						<ul>
							<li><a href="http://www.w3.org/TR/html5/" target="_blank">W3C</a></li>
							<li><a href="http://www.w3schools.com/html/html5_intro.asp" target="_blank">W3C_School</a></li>
							<li><a href="http://validator.w3.org/" target="_blank">Validator</a></li>
						</ul>
					</li>
				<li><a href="http://nl.wikipedia.org/wiki/CSS">CSS</a>
						<ul>
							<li><a href="http://www.w3.org/standards/techs/css" target="_blank">Current_Status</a></li>
							<li><a href="http://www.w3schools.com/css/css3_intro.asp" target="_blank">W3C_School</a></li>
							<li><a href="https://jigsaw.w3.org/css-validator/" target="_blank">Validator</a></li>
						</ul>
					</li>
			</ul>
		</li>
		<li><a href="about.html">About</a></li>
		<li><a href="help.html">Help</a></li>
	</ul>
</nav>
		</div>
	<br /> 
	<br />
	<div class="header">
		<iframe src="srchform.htm" width="400px" height="34px" border="0" frameborder="0" scrolling="no"></iframe>
	</div>		
	<div class="sub-header">
		<input type="button" id="more_cols" value="More columns" />
    	<input type="button" id="less_cols" value="Less columns" />
    	<input type="button" id="more_gap" value="More gap" />
    	<input type="button" id="less_gap" value="Less gap" />
	</div>
		
</div>

	

</header>

<div class="container" id="container">
<!-- <p>Kijken naar docker data center => om lokaal een regisgtry te draaien</ul>

    <p>Een container is een in pricipe een vorm van proces isolatie.</ul> -->


    install latest version on debian
    https://docs.docker.com/engine/installation/linux/ubuntulinux/

    Boot2Docker
    https://github.com/boot2docker/windows-installer/releases
    https://github.com/boot2docker/osx-installer/releases
    Docker daemon draait niet op windows en osx, mbv boot2docker, die een vm installeert op virtualbox, wordt docker op je machine geinstalleerd.
     Voor windows bestaat er ook een optie om msysgit te installeren, dit is een alternatief voor de wndows cmd terminal.

    Om docker commando's te kunnen uitvoeren zonder het sudo commando, moet uw gebruiker worden toegevoegd aan de docker group:
    <ul class="command">sudo usermod -aG docker &lt;user&gt;></ul>

    hierdoor wordt het voltooien van docker commando's met de tab toets ook mogelijk
    Op sommige distributies bestaat de docker groep niet, maak hem in dat geval aan met <ul class="command">sudo groupadd docker</ul>.
    Realiseer je dat gebruikers in de docker groep in principe root toegang hebben.

    uitloggen en opnieuw inloggen voor het resultaat

    images are specified by repository:tag
    <ul class="command">docker pull ubuntu:12.04</ul>

    <ul class="command"> docker run [options] [image] [command] [args]</ul>
    image wordt aangeroepen met repository:tag,
    <ul class="command">docker run ubuntu:14.04 echo "Hello World"</ul>
    <ul class="command">docker run ubuntu ps ax</ul>
    <ul class="command">docker version</ul>
    <h2>Find your container</h2>
    <span class="command">docker ps </span>to list running containers <span class="command">-a </span>flag to list all containers

    <h2>Container with Terminal</h2>
    Gebruik de -i en -t flag met docker<br>
    -i flag verteld docker te verbinden met STDIN van de container,<br>
    -t flag specificeerd de pseudo-terminal<br>
    Je dient het terminal proces als commamndo mee te geven (bash)

    <ul class="command">docker run -it ubuntu:latest bash</ul>

    <h2>Exit the Terminal</h2>
    <span class="command">Exit</span> om de terminal af te sluiten en terug te keren naar de host terminal, dit sluit de container<br>
    Om uit de terminal te stappen zonder de container te sluiten <ul class="command">CTRL + P + Q</ul>

    <span class="command">Docker ps command</span><br><br>
    <span class="command">docker ps -q </span> #om alleen het container ID te laten zien<br><br>
    <span class="command">docker ps -l </span> #om de laatste container die is gestart te laten zien<br><br>
    <span class="command">docker ps -aq </span> #all containers with only their short ID<br><br>
    <span class="command">docker ps -lq </span> #list the short ID van de laatst gestarte container<br><br>
    <span class="command">docker ps -a --filter "exited-1"</span> #past een filter toe op exit code 1 (exit with error), momenteel kan er worden gefiltert op exit-code en status ( restarting, running, exited and paused)<br><br>
<br>
    Running in detached mode, wordt ook wel op de achtergrond genoemd of als een daemon
    -d flag,
    om de output te bekijken gebruik je:
    <ul class="command"> docker logs [container id]</ul>

    maak een centos container en voor het ping commando 50 keer uit
    <ul class="command">docker run -d centos:7 ping 127.0.0.0 -c 50</ul>

    <ul class="command">docker run -d -P nginx</ul>
    Met de -P flag wordt de container port gemapped met de host port

    <h2>attach en detach</h2>
    hier loop je het risico de container af te sluiten door per ongeluk op crtl C te drukken
    vb, <ul class="command">docker run -d ubuntu ping 127.0.0.1 -c 50</ul>
    <ul class="command">docker attach [container id]</ul> of naam, verlaat de container met Crtl + P + Q

    <h2>docker exec </h2>commando wordt gebrukt om extra processen in de container te starten
    <ul class="command">docker exec -i -t [container id] bash</ul>
    als men deze terminal (bash) afsluit blijft de container draaien.

    <h2>docker logs bekijken</h2>
    <ul class="command">docker logs container name</ul>
    -f optie als tail -f
    <ul class="command">docker logs --tail 5 -f containerid</ul>
    <ul class="command">CRTL + C</ul> to exit

    <h2>Stopping a container</h2>
    <ul class="command">docker stop</ul>, sends a SIGTERM to the main container proces, proces then receives a SIGKILL after a grace period, -t flag grace period can be specified
    <ul class="command">docker kill</ul>, sends SIGKILL immediately to mail container proces

    <h2>Restart a container</h2>
    docker start to restart a container that has been stopped, the container will start using the same options and command specified previously.
    Can attach to the container with the -a flag

    <h2>Formatting docker inspect output</h2>
    <ul class="command">docker inspect --format=`{{.&lt;field1&gt;.&lt;field2&gt;}}' &lt;container id&gt;</ul>
    <ul class="command">docker inspect --format=`{{.Config.Cmd}}' &lt;container id&gt;</ul>

     Deleting containers
    <ul class="command">docker rm &lt;containerid&gt;</ul>

     Delete all containers that are stopped
     Use dockers ps -aq to list id's of all containers, feed the output to docker rm
    <ul class="command">   docker rm $(docker ps -aq)</ul>

     List all stopped containers
    <ul class="command">    docker ps --filter=`status=exited`</ul>

     delete the latest container that was run
    <ul class="command">    docker rm $(docker ps -ql)</ul>

     Comparing containes with docker diff
    <ul class="command">    docker diff mad_wilson</ul>

     <h2>Methoden om images te bouwen</h2>
     1. commit changes from a container as a new image
     allows you to build images interactively
     get terminal access inside a container and instal the necessary pograms and your application
     then save the container as a new image using the docker commit command
    <ul class="command">   docker commit [options] [container id] [repository:tag]</ul>
    <ul class="command">    docker commit 984n5843j594857398c jaccokip/myapplication:1.0</ul>

     <h2>2. build from Dockerfile</h2>
     create a Dockerfile in een nieuwe map of in een bestaande applicatie map
     Schrijf de instructies om het image te bouwen (what program to install, what base image to use, what command to run)
     Build examples
    #comment in een build file
     FROM ubuntu:14.04 of FROM johnytu/myapplicaiton:1.0 of FROM company.registry:5000/myapplication:1.0
     RUN apt-get install vim
     RUN apt-get install curl
     draai docker build commando of het image te bouwen van het Dockerfilesd
    <ul class="command">    docker build -t johnytu/myimage:1.0 .</ul>  # Build an image use the current folder as context path.
    <ul class="command">    docker build -t johnytu/myimage:1.0 myproject</ul> # as above but use the project folder as context path

     <h>3. Import a tarbal into Docker as a standalone base layer</h>

     Docker uses exact strins in your Dockerfile to compare with the cache, simply changing the order of instructions will invalidate the cache. To disable the cache manually use:
     --no-cache flag
    <ul class="command">   docker build --no-cache myimage</ul>

     <h2>   Run instruction aggregation</h2>h
     Can aggregate multiple RUN instructions by using &&
     Commands will all be run in the same container and committed as a new image at the end
     Reduces the number of image layers that are produced.

     <h2>Docker history</h2> command shows us the layers that make up an image

     <h2>CMD instruction</h2>
     CMD defines a default command to execute when a container is created
     Shell format and EXEC format
     Can only be specified once in a Dockerfile, if specified multiple times the last CMD instruction is executed
    <ul class="command">   Can be overridden at run time
     Shell format
     CMD ping 127.0.0.1 -c 30
     Exec format
     CMD ["ping", "127.0.0.1", "-c", "30"]</ul>

     <h2>ENTRYPOINT instruction</h2>
     Defines the command that wil be run when a container is excuted
     Run time arguments and CMD instructions are passed as parameters to the ENTRYPOINT instruction
     Container essentially runs as an executable
    <ul class="command">    ENTRYPOINT ["ping"]</ul>

     shell vs exec format
     In shell form, the command will run inside a shell with /bin/sh -c
    <ul class="command">    RUN apt-get update</ul>

     Exec format allows execution of command in images that don't have /bin/sh
    <ul class="command">    RUN ["apt-get", "update"]</ul>

     Shell form is easier to write and you can perform shell parsing of variables
    <ul class="command">   CMD sudo -u $(USER) java ... .</ul>

     Exec form does not require image to have a shell
     For ENTRYPOINT instructions, using shell form will prevent the ability to specify arguments at run time
     - The CMD argument will not be used as parameters for ENTRYPOINT

     Overriding ENTRYPOINT
     To override teh command specified by ENTRYPOINT, use the --entrypoint flag, Useful for troubleshooting your images
    <ul class="command">docker run -it --entrypoint bash myimage</ul>

     <h2>COPY instruction</h2>h
     The copy instruction copies new files or directories from a specified source and adds them to the container filesystem at a specified place.
    <ul class="command"> COPY &lt;SRC&gt; &lt;dest&gt;</ul>
     The &lt;src&gt; path must be inside the build context, if the &lt;src&gt; path is a directory, all files in de directory are copied, the directory itself is not copied. You can specify multiple <src> directories
    <ul class="command">    COPY server.conf / </ul># copy the server.conf file in the build content into the root folder of the container.

     <h2>Specify a working directory</h2>
    <ul class="command">WORKDIR </ul>instructions allow us to set the working directory for any subsequent RUN, CMD, ENTRYPOINT and COPY instructions to be executed.
    <ul class="command">WORKDIR /path/to/folder</ul> # path can be absolute or relative to the current working directory. Instruction can be used multiple times


    <h2>MAINTAINER Instruction</h2>
    <p>Specifies who wrote the Dockerfile
    Optional but best practice to include
    Usually placed straight after de FROM instraction

     <h2>ENV instruction</h2>
    <p>Used to set environment variables in any container launched from the image
    Syntax: ENV &lt;variable&gt;&lt;value&lt;
     ENV JAVA_HOME /usr/bin/java
     ENV APP_PORT 8080

     <h2>ADD insntruction</h2>
    <p>Copies new files or directories from a specified source and adds them to the container filesystem at a specified destination.
     Syntax: ADD &lt;src&gt; &lt;dest&gt; The src path is relative to the directory containing the Dockerfile
     If the src path is a directory, all files in the directory are copied. The directory itself is not copied.
     You can specify multiple src directory
     ADD /src /myapp/src

     <h2>COPY vs ADD</h2>
    <p>Both instructions perform a near identical funtion
     ADD has the ability to auto unpack tar files
     ADD instruction also allows you to specify  URL for you content (although this is not recommended)
     Both instructions use a checksum against the files added. If the checksum is not equal then the test fails and the build cache wil be invalidated, Because it means we have modified the files

     <h2>Best practice for writing Dockerfiles</h2>
    <p>Remember, each line in a Dockerfile creates a new layer
     You need to find the right balance between having lots of layers created for the image and readability of the Dockerfile
     Don't install unnecessary packages
     One ENTRYPOINT per Dockerfile
     Combine similar commands into one by using "&&" and "\"
     Example: RUN apt-get update && \
     apt-get install -y vim && \
     apt-get install -y curl
     Use the caching systemto your advantage, the order of statments is important, add files that are least likely tochange first and the ones most likely to change last.

     <h2>Distibuting your image</h2>
    <p>2 options: Push to Docker Hub (public or private repository)
     Push to your own registy server

     <h2>Pushing Images to Docker Hub</h2>
    <p>Use docker push command, syntax: docker push [repo:tag]
     Local repo must have same name adn tag as the Docker Hub repo
     Only the image layers that have changed get pushed
     You will be prompted to login to your Docker Hub account

     <h2>Tagging Images</h2>
    <p> Used to rename a local image repository before pushing to Docker Hub
     Syntax: docker tag [image ID] [repo:tag]
     docker tag [local repo:tag] [Docker HUb repo:tag]

     docker tag edfc212de17d trainingteam/testexample:1.0
     docker tag johnnytu/testimage:1.5 trainingteam/testexample

     One image many tags

     <h2>Deleting local images</h2>
    <p>docker rmi [image id]
     docker rmi [repo:tag]

     <h2>Volumes</h2>
    <p>A Volume is a designated directory in a countainer, which is designed to persist data, independent of the container's life cycle.
     Volume changes are excluded when updating an image
     Persist when a container is deleted
     Can be mapped to a host folder
     Can be shared between containers

    <p>Volumes bypass the copy on write system
     Act as passthrough to the host filesystem
     When you commit a countainer as a new image, the content of the volume will not be brought into that image
     If a RUN instruction is a Dockerfile changes the content th content of a volume, those changes are not recorded either.

    <p>De-couple the data that is stored, from the container which created the data
     Good for sharing data between containers
     Can setup a data container which has a volume you mount in other containers
     Share directories between multiple containers
     Bypassing the copy on write system to achieve native disk I/O
     Share a host directory with a container
     Share a single file between the host and container

     <h2>Mount a Volume</h2>
    <p>Volumes can be mounted when running a container
     Use the -v option on docker run
     Volume paths specified must be absolute
     Can mount multiple volumes by using the -v option multiple times
     Execute a new container and mount the folder /myvolume into its system
     docker run -d -P -v /myvolume nginx:1.7
     Example of mounting multiple volumes
     docker run -d -P -v /data/www -v /data/images nginx

     <h2>Where are your volumes</h2>
    <p>Volumes exist independently from containers, if a volume is stopped we can still access our volume.
     To find where the volume is, use docker inspect on the container

     <h2>Deleting a volume</h2>
    <p>Volumes are not deleted when you delete a container
     To remove the volumes associated with a container use the -v option in the docker rm command.
     docker rm -v &lt;container id&gt;

     <h2>Mounting host folders to a volume</h2>
    <p>When running a container, you can map folders on the host to a volume
     The files from the host folder will be present in the volume
     CHanges made on the host are reflected inside the container volume
     Syntax: docker run -v [host path]:[container path]:[rw|ro] # rw or ro controls the write status of the volume
     docker run -d -v /home/user/public_html:/data/www ubuntu
     files inside /home/user/public_html on the host will apear in the /data/www folder on the container.
     If the host path or container path does not exist, it wil be created
     If the container path is a folder with existing contenyt, the files will be replaced by host path

     <h2>Volumes in Dockerfile</h2>
    <p>VOLUME instruction creates a mount point
     Can specify arguments in a JSON array or string
     Cannot map volumes to host directories
     Volumes are initialized when the container is executed
     String example: VOLUME /myvol
     String example with multiple volumes: VOLUME /www/website.com /www/website2.com
     JSON example: VOLUME ["myvol", "myvol2"]
     Example Dockerfile with Volumes, When we run a container from this image, the volume will be initialized along with any data in the specified location
     If we want to setup default files in the volume folder, the folder and file must be created first

     FROM ubuntu:14.04

     RUN apt-get update
     RUN apt-get install -y vim \
     wget

     RUN mkdir /data/myvol -p && \
     echo "hello worldÂ¨ > /data/myvol/testfile
     VOLUME ["/data/myvol"]

     <h2>Data containers</h2>
    <p> A data container is a container created for the purpose of referencing one or many volumes
     Data containers don't run any application or proces
     Used when you have persistent data that needs to be shared with other containers
     When creating a data container, you should give it a custom name to make it easier to reference

     <h2>Custom container names</h2>
    <p>By default, containers we create, have a randomly generated name
     to give your container a specific name, use the --name option on the docker run command
     Existing container can be renamed using the docker rename command docker rename <old name> <new name>
     Create a container and name it mynginx
     docker run -d -P --name mynginx nginx
     docker rename happy_einstein mycontainer

    <p>creating data containers
     docker run --name mydata -v /data/app1 busybox true

     <h2>chaining containers</h2>
    <p>docker run --name logdata -v /var/log/nginx busybox
     docker run --name webdata -v /home/jacco/public_html:/usr/share/nginx/html busybox
     docker run --name webserver -d -P --volumes-from webdata --volumes-from logdata nginx

     <h2> backup your data container</h2>
    <p>docker run --volumes-from logdata \
     -v /home/jacco/backups:/backup \
     ubuntu:14.04 \
     tar cvf /backup/nginxlogs.tar /var/log/nginx

     <h2>inspecting an image</h2>
    <p>docker inspect ubuntu:14.04
     or
     docker inspect &lt;image id&gt;

     <h2>Docker networking model</h2>
    <p>Containers cannot have a public IPv4 addres
     They are allocated in a private address range
     Services running on a docker container must be exposed port by port
     Container ports have to be mapped to the host port to avoid conflicts

     <h2>The Docker bridge</h2>
    <p>When docker strart, it creates a virtual interface called docker0 on the host machine
     docker0 is assigned a random ip addres and subnet from the private range defined by RFC1918
     docker0 interface is a virtual Ethernet bridge interface
     it passes or switches packets between two connected devices just like a physical bridge or switch (host to container - container to container)
     Each new container gets one interface that is automatically attached to the docker0 bridge

     <h2>Checking the bridge interface</h2>
    <p>We can use the brctl (bridge control) command to check the interface on our docker0 bridge
     Install bridge-utils package to get the command (apt-get install bridge-utils)
     run:brctl show docker0


     <h2> Check container network properties</h2>
     use docker inspect command and look for the NeworkSettings field

    <h2>Manual port mapping</h2>
     Use -p option (lowercase p) in the docker run command
     syntax -p [host port]:[container port]
     To map multiple ports, specify the -p option multiple times
     Map port on the host to port 80 on the nginx container and port 81 on the host to port 8080 on the nginx container
     docker run -d -p 80:80 -p 81:8080 nginx

     We can use docker port command for displaying port mappings (and docker ps)

     <h2>EXPOSE instruction</h2>
     Configure which ports a container will listen on at runtime
     Port still need to be mapped when containers is executed

     FROM ubuntu:14.04
     RUN apt-get update
     RUN apt-get install -y nginx

     EXPOSE 80 443

     CMD ["nginx", "-g", "daemon off;"]

     <h2>linking Containers</h2>
     <p>Linking is a communication meethod between containers which allows them to securely transfer data from one to another
     Source and recipient containers
     Recepient containers have acce to data on a source container
     Links are established based on container names.
     Containers can talk to each other without having to expose ports to the host
     Essential for micro service application architecture
     Example:
     - container with Tomcat running
     - container with MySQL running
     - Application on Tomcat needs to connect to MySQL</p>

     <p>Create the source container first
     Create the recipient container and use the --link option</p>

        <p>Best Practice- give your container meaningful names
     Format for linking: name:alias</p>

        <p>Create the source container using the postgres
     docker run -d --name database postgress</p>

        <p>Create the recipient container and link it
     docker run -d -P --name website --link database:db nginx</p>

     <h2>The underlyin mechanism</h2>
        <p>Linking provides a secure tunnel between the containers
     Docker will create a set of environment variables based on your --link parameter
     Docker also exposes the environment variables from the source container
     - Only the variables created by Dockler are exposed
     - Variabes are prefixed by the link alias
     - ENV instruction in the container Dockfile
     - Variables defined during docker run
     DNS lookup entry will be added to /etc/hosts file based on your alias</p>

     <h2>Controlling and configuring the Daemon</h2>
        <p>     The way you start/stop and configure docker depends on
     - are we running it as a service
     - What linux distribution
     service vs systemctl command
     Running interactively in the foreground (docker -d &), send SIGTERM to docker proces to stop
     - run pidof docker
     - sudo kill $(pidof docker)
        </p>
        <p>
     If starting the Daemon from the Docker command you just specify the various options as a flag
     sudo docker -d [options] &</p>
        <p>
     For Ubuntu and Debian located in /etc/default/docker use DOCKER_OPTS to control the startup options for the daemon when running as a service
     Example: Start daemon with log level of debug and allow connections to an insecure registry at the domain of myserver.org
     DOCKER_OPS="--log-level=debug --insecure-registry=myserver.org:5000"
        </p>
        <p>
     CentOs uses systemd to run docker, look at the docker.service file to see how docker is started.
     /usr/lib/systemd/system/docker.service
        </p>
        <p>
     a full reference list of all daemon options:
     https://docs.docker.com/reference/commandline/cli/#daemon
        </p
     <h2>Docker daemon logging</h2>
     Start the docker daemon with --log-level parameter and specify the logging level
     debug, info, warn, error and fatal

     <h2>Connecting to a remote daemon</h2>
     A few things we need to setup
     First, the docker daemon we want to connect to needs to be listening on a tcp socket
     For security purpost we should use a HTTPS encrypted socket, which will require us to setup TLS
     Then we point our client to the remote Daemon

     <h2>Docker Daemon socket option</h2>
     The docker daemon listens for remote API request on three types of Socket
     - unix
     - tcp
     - fd (for Linux distributions using Systemd)

     The default socket is a unix domain socket created at /var/run/docker.sock
     This socket requires root permission

     <h2>Error connecting to socket</h2>
     If you get the eror message below, it typically means
     - The Docker daemon is not running
     - You do not have permission to make an API call to the docker daemon (i.e. you didn't use sudo in your command or you are not in the docker group)
     - Your docker client is trying to connect to the daemon using the unix socket but the daemon is nog listening on it
     - You are not using TLS to connect to the daemon
     johnnytu@docker-ubuntu:~$ docker ps
     FAT[0000] Get http:///var/run/docker.dock/v1.18/container/json:
     dial unix /var/run/docker.sock: no such file or directory.
     Are you trying to to conect to a TLS-enabled daemon without TLS?
     <h2>Listening on TCP socket</h2>
     To configure the Docker daemon to listen on a TCP socket, we start the daemon using the --host option and specify the TCP address and port
     - Can also use -H
     Be aware that by default the TCP socket is un-encrypted
     For the address, you can specify an IP address to listen on or specify 0.0.0.0 to listen on all network interfaces.
     Port numbers should be 2375 for un-encrypted communication and 2376 for encrypted communication
     Using docker command, listen on TCP socket for all network interfaces
     docker -d -H tcp://0.0.0.0:2375

     Using docker command, listen on TCP socket on a particular IP address
     docker -d -H tcp://192.168.0.1:2375

     Configure via the upstart configuration file /etc/default/docker
     DOCKER_OPS="-H tcp://192.168.0.1:2375"

    <h2>Connect the client to the daemon</h2>
     By default the Docker client assumes the daemon is listening on a unix socket
     if the daemon is listening on a TCP socket, we have to configure the cleint to connect to a particular host
     Two metehod
     - Use the -H flag on the docker command
     docker -H tcp://localhost:2375
     docker -H tcp://193.241.228.93:2375

     - Configure the DOCKER_HOST environment variable
     export DOCKER_HOST="tcp://localhost:2375"

</div>


<footer>
	<p>
		&copy; NoCopyright  by me
	</ul>
</footer>
		</div>
	</body>
</html>
