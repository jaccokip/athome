<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame
	Remove this if you use the .htaccess -->
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />

	<title>HTML</title>
	<meta name="description" content="">
	<meta name="author" content="jacco" >
	<!-- persistent stylesheet -->
	<link rel="stylesheet" type="text/css" href="css/menu.css">
	<link rel="stylesheet" type="text/css" href="css/sober.css">
	<link rel="stylesheet" type="text/css" href="css/sober.css" title="Default">
	<link rel="alternate stylesheet" type="text/css" href="css/pinned_menu.css" title="pinned">
	
	<link rel="alternate stylesheet" type="text/css" href="css/command.css" title="stars">
	<link rel="alternate stylesheet" type="text/css" href="css/com_back.css" title="grey">
	<!-- <link rel="alternate stylesheet" type="text/css" href="css/python.css" title="python">
	<link rel="alternate stylesheet" type="text/css" href="css/tcpdump.css" title="tcpdump"> -->
	<link rel="alternate stylesheet" type="text/css" href="css/nmap.css" title="nmap">

<!--	<script src="scripts/nomouse.js"></script> -->
	<script type="text/javascript" src="scripts/jquery-1.11.2.js"></script>
	<script type="text/javascript" src="scripts/col-test.js"></script>

	<script src="scripts/swapstyle.js"></script>
	<script type="text/javascript">
	if( self != top ) { document.write('<style type="text/css">\n#backlinks { display: none; }\n<\/style>'); }
	</script>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- Replace favicon.ico & apple-touch-icon.png in the root of your domain and delete these references -->
	<link rel="shortcut icon" href="favicon.ico">
	<link rel="apple-touch-icon" href="/apple-touch-icon.png">
</head>

<body>

<header>
	<div>
		<nav>
			<ul>
				<li><img id="in_out" onclick="changeStyle('pinned')" src="images/Pin.png" width="30" height="30"></a></li>
				<li><a href="index.html">Home</a>
					<ul>
						<li><a href="styles.html">Styles</a>
							<ul>
								<li><a href="#" onClick="changeStyle('grey');">cmd-line</a></li>
								<li><a href="#" onClick="changeStyle('stars');">stars</a></li>
								<!-- <li><a href="#" onClick="changeStyle('python');">python</a></li>
								<li><a href="#" onClick="changeStyle('tcpdump');">tcpdump</a></li>
								<li><a href="#" onClick="changeStyle('nmap');">nmap</a></li> -->
								<li><a href="#" onClick="changeStyle('Default');">Reset to default</a></li>
							</ul>
						</li>
					</ul>
				</li>
			<li><a href="index.html">Naslag_OS <span class="caret"></span></a>
				<ul>
					<li><a href="linux_commands.html">Commands</a></li>
					<li><a href="tcpdump.html">Tcpdump</a></li>
					<li><a href="nmap.html">Nmap</a></li>
					<li><a href="vim.html">Vim</a></li>
				</ul>
			</li>
			<li><a href="index.html">Naslag<span class="caret"></span></a>
				<ul>
					<li><a href="cat_api.html">Elasticsearch</a></li>
					<li><a href="docker.html">Docker</a></li>
					<li><a href="Escape_code.html">Escape characters</a></li>
					<li><a href="git.html#table">Git</a></li>
					<li><a href="puppet.html">Puppet</a>
						<ul>
						<li><a href="puppet_training.html">Puppet_Training</a></li>
					</ul>
					</li>
					<li><a href="python.html">Python</a>
						<ul>
							<li><a href="python_examples.html">Examples</a></li>
						</ul>
					</li>

				</ul>
			</li>
			<li><a href="url_naar.html">Off Site</a>
				<ul>
					<li><a href="http://www.apache.org/" target="_blank">apache</a>
						<ul>
							<li><a href="http://httpd.apache.org/docs/2.0/misc/rewriteguide.html" target="_blank">rewrite</a></li>
							<li><a href="https://www.addedbytes.com/articles/for-beginners/url-rewriting-for-beginners/" target="_blank">rewrite_dummies </a></li>
						</ul>
					</li>
					<li><a href="http://www.ibm.com">IBM</a>
						<ul>
						<li><a href="http://www.ibm.com/developerworks" target="_blank">developers</a></li>
					</ul>
				</li>
				<li><a href="http://nl.wikipedia.org/wiki/HyperText_Markup_Language">HTML</a>
						<ul>
							<li><a href="http://www.w3.org/TR/html5/" target="_blank">W3C</a></li>
							<li><a href="http://www.w3schools.com/html/html5_intro.asp" target="_blank">W3C_School</a></li>
							<li><a href="http://validator.w3.org/" target="_blank">Validator</a></li>
						</ul>
					</li>
				<li><a href="http://nl.wikipedia.org/wiki/CSS">CSS</a>
						<ul>
							<li><a href="http://www.w3.org/standards/techs/css" target="_blank">Current_Status</a></li>
							<li><a href="http://www.w3schools.com/css/css3_intro.asp" target="_blank">W3C_School</a></li>
							<li><a href="https://jigsaw.w3.org/css-validator/" target="_blank">Validator</a></li>
						</ul>
					</li>
			</ul>
		</li>
		<li><a href="about.html">About</a></li>
		<li><a href="help.html">Help</a></li>
	</ul>
</nav>
	</div>
	<br /> 
	<br /> 	
	<div class="header">
		<iframe src="srchform.htm" width="400px" height="34px" border="0" frameborder="0" scrolling="no"></iframe>
	</div>
	
	<div class="sub-header">
		<input type="button" id="more_cols" value="More columns" />
    	<input type="button" id="less_cols" value="Less columns" />
    	<input type="button" id="more_gap" value="More gap" />
    	<input type="button" id="less_gap" value="Less gap" />
	</div>

</header>

<!-- <div class="container" id="container"> -->
<div class="container" id="container">

<p>
All the cat commands accept a query string parameter help to see all the headers and info they provide, 
and the /_cat command alone lists all the available commands.
</p>
<h2>verbose</h2> -Each of the commands accepts a query string parameter v to turn on verbose output.
<p class="command">
% curl 'localhost:9200/_cat/master?v'<br />
id          &nbsp;ip    &nbsp;node<br />
EGtKWZlWQYWDmX29fUnp3Q 127.0.0.1 Grey, Sara<br />
</p>

<h2>help</h2> -Each of the commands accepts a query string parameter help which will output its available columns.
<p class="command">
% curl 'localhost:9200/_cat/master?help'<br />
id  | node id<br />
ip  | node transport ip address<br />
node | node name<br />
</p>
<h2>headers</h2> -Each of the commands accepts a query string parameter h which forces only those columns to appear.
<p class="command">
% curl 'n1:9200/_cat/nodes?h=ip,port,heapPercent,name'<br />
192.168.56.40 9300 40.3 Captain Universe<br />
192.168.56.20 9300 15.3 Kaluu<br />
192.168.56.50 9300 17.0 Yellowjacket<br />
192.168.56.10 9300 12.3 Remy LeBeau<br />
192.168.56.30 9300 43.9 Ramsey, Doug<br />
</p>
<h2>Numeric formats</h2>
Many commands provide a few types of numeric output, either a byte value or a time value. By default, these types are human-formatted, for example, 3.5mb instead of 3763212. The human values are not sortable numerically, so in order to operate on these values where order is important, you can change it.

Say you want to find the largest index in your cluster (storage used by all the shards, not number of documents). The /_cat/indices API is ideal. We only need to tweak two things. First, we want to turn off human mode. We’ll use a byte-level resolution. Then we’ll pipe our output into sort using the appropriate column, which in this case is the eight one.
<p class="command">
% curl '192.168.56.10:9200/_cat/indices?bytes=b' | sort -rnk8<br />
green wiki2 3 0 10000  0 105274918 105274918<br />
green wiki1 3 0 10000 413 103776272 103776272<br />
green foo  1 0  227  0  2065131  2065131<br />
</p>
<!--
<p>
<h2>aliases</h2>
aliases shows information about currently configured aliases to indices including filter and routing infos.
<p class="command">
% curl '192.168.56.10:9200/_cat/aliases?v'<br />
alias &nbsp;index filter indexRouting searchRouting<br />
alias2 test1 *   &nbsp;-      &nbsp;-<br />
alias4 test1 -   &nbsp;2      &nbsp;1,2<br />
alias1 test1 -   &nbsp;-      &nbsp;-<br />
alias3 test1 -   &nbsp;1      &nbsp;1<br />
</p>
The output shows that alias has configured a filter, and specific routing configurations in alias3 and alias4.

If you only want to get information about a single alias, you can specify the alias in the URL, for example /_cat/aliases/alias1.
-->

<h1>cat allocation</h1>
allocation provides a snapshot of how shards have located around the cluster and the state of disk usage.
<p class="command">
% curl '192.168.56.10:9200/_cat/allocation?v'<br />
shards diskUsed diskAvail diskRatio ip      &nbsp;node<br />
   1  &nbsp;5.6gb  &nbsp;72.2gb   &nbsp;7.8% 192.168.56.10 Jarella<br />
   1  &nbsp;5.6gb  &nbsp;72.2gb   &nbsp;7.8% 192.168.56.30 Solarr<br />
   1  &nbsp;5.5gb  &nbsp;72.3gb   &nbsp;7.6% 192.168.56.20 Adam II<br />
</p>
Here we can see that each node has been allocated a single shard and that they’re all using about the same amount of space.

<h2>cat count</h2>
count provides quick access to the document count of the entire cluster, or individual indices.
<p class="command">
% curl 192.168.56.10:9200/_cat/indices<br />
green wiki1 3 0 10000 331 168.5mb 168.5mb<br />
green wiki2 3 0  428  0   8mb   8mb<br />
</p>
<p class="command">
% curl 192.168.56.10:9200/_cat/count<br />
1384314124582 19:42:04 10428<br />
</p>
<p class="command">
% curl 192.168.56.10:9200/_cat/count/wiki2<br />
1384314139815 19:42:19 428<br />
</p>
<h2>cat fielddata</h2>
fielddata shows information about currently loaded fielddata on a per-node basis.
<p class="command">
% curl '192.168.56.10:9200/_cat/fielddata?v'<br />
id          &nbsp;host  &nbsp;ip      &nbsp;node     &nbsp;total  body  &nbsp;text<br />
c223lARiSGeezlbrcugAYQ myhost1 10.20.100.200 Jessica Jones 385.6kb 159.8kb 225.7kb<br />
waPCbitNQaCL6xC8VxjAwg myhost2 10.20.100.201 Adversary   435.2kb 159.8kb 275.3kb<br />
yaDkp-G3R0q1AJ-HUEvkSQ myhost3 10.20.100.202 Microchip   284.6kb 109.2kb 175.3kb<br />
Fields can be specified either as a query parameter, or in the URL path:<br />
</p>
<p class="command">
% curl '192.168.56.10:9200/_cat/fielddata?v&fields=body'<br />
id          &nbsp;host  &nbsp;ip      &nbsp;node     &nbsp;total  body<br />
c223lARiSGeezlbrcugAYQ myhost1 10.20.100.200 Jessica Jones 385.6kb 159.8kb<br />
waPCbitNQaCL6xC8VxjAwg myhost2 10.20.100.201 Adversary   435.2kb 159.8kb<br />
yaDkp-G3R0q1AJ-HUEvkSQ myhost3 10.20.100.202 Microchip   284.6kb 109.2kb<br />
</p>
<p class="command">
% curl '192.168.56.10:9200/_cat/fielddata/body,text?v'<br />
id          &nbsp;host  &nbsp;ip      &nbsp;node     &nbsp;total  body  &nbsp;text<br />
c223lARiSGeezlbrcugAYQ myhost1 10.20.100.200 Jessica Jones 385.6kb 159.8kb 225.7kb<br />
waPCbitNQaCL6xC8VxjAwg myhost2 10.20.100.201 Adversary   435.2kb 159.8kb 275.3kb<br />
yaDkp-G3R0q1AJ-HUEvkSQ myhost3 10.20.100.202 Microchip   284.6kb 109.2kb 175.3kb<br />
</p>
The output shows the total fielddata and then the individual fielddata for the body and text fields

<h2>cat health</h2>
health is a terse, one-line representation of the same information from /_cluster/health. It has one option ts to disable the timestamping.
<p class="command">
% curl 192.168.56.10:9200/_cat/health<br />
1384308967 18:16:07 foo green 3 3 3 3 0 0 0<br />
</p>
<p class="command">
% curl '192.168.56.10:9200/_cat/health?v&ts=0'<br />
cluster status nodeTotal nodeData shards pri relo init unassign tasks<br />
foo   green     &nbsp;3    &nbsp;3   &nbsp;3  3  &nbsp;0  &nbsp;0    &nbsp;0   0<br />
</p>
A common use of this command is to verify the health is consistent across nodes:
<p class="command">
% pssh -i -h list.of.cluster.hosts curl -s localhost:9200/_cat/health<br />
[1] 20:20:52 [SUCCESS] es3.vm<br />
1384309218 18:20:18 foo green 3 3 3 3 0 0 0 0<br />
[2] 20:20:52 [SUCCESS] es1.vm<br />
1384309218 18:20:18 foo green 3 3 3 3 0 0 0 0<br />
[3] 20:20:52 [SUCCESS] es2.vm<br />
1384309218 18:20:18 foo green 3 3 3 3 0 0 0 0<br />
</p>
A less obvious use is to track recovery of a large cluster over time. With enough shards, starting a cluster, or even recovering after losing a node, can take time (depending on your network & disk). A way to track its progress is by using this command in a delayed loop:
<p class="command">
% while true; do curl 192.168.56.10:9200/_cat/health; sleep 120; done<br />
1384309446 18:24:06 foo red 3 3 20 20 0 0 1812 0<br />
1384309566 18:26:06 foo yellow 3 3 950 916 0 12 870 0<br />
1384309686 18:28:06 foo yellow 3 3 1328 916 0 12 492 0<br />
1384309806 18:30:06 foo green 3 3 1832 916 4 0 0<br />
^C<br />
</p>
In this scenario, we can tell that recovery took roughly four minutes. If this were going on for hours, we would be able to watch the UNASSIGNED shards drop precipitously. If that number remained static, we would have an idea that there is a problem.

Why the timestamp?edit

You typically are using the health command when a cluster is malfunctioning. During this period, it’s extremely important to correlate activities across log files, alerting systems, etc.

There are two outputs. The HH:MM:SS output is simply for quick human consumption. The epoch time retains more information, including date, and is machine sortable if your recovery spans days.

<h2>cat indices</h2>
The indices command provides a cross-section of each index. This information spans nodes.
<p class="command">
% curl 'localhost:9200/_cat/indices/twi*?v'<br />
health status index  &nbsp;pri rep docs.count docs.deleted store.size pri.store.size<br />
green &nbsp;open  twitter  &nbsp;5  1   &nbsp;11434      &nbsp;0    64mb      32mb<br />
green &nbsp;open  twitter2  2  0    2030      &nbsp;0   &nbsp;5.8mb     &nbsp;5.8mb<br />
</p>
We can tell quickly how many shards make up an index, the number of docs, deleted docs, primary store size, and total store size (all shards including replicas).

</3>Primariesedit</h2>

The index stats by default will show them for all of an index’s shards, including replicas. A pri flag can be supplied to enable the view of relevant stats in the context of only the primaries.

<h2>Examplesedit</h2>

Which indices are yellow?
<p class="command">
% curl localhost:9200/_cat/indices | grep ^yell<br />
yellow open &nbsp;wiki   2 1 &nbsp;6401 1115 151.4mb 151.4mb<br />
yellow open &nbsp;twitter &nbsp;5 1 11434  &nbsp;0  &nbsp;32mb  &nbsp;32mb<br />
</p>
What’s my largest index by disk usage not including replicas?
<p class="command">
% curl 'localhost:9200/_cat/indices?bytes=b' | sort -rnk8<br />
green open &nbsp;wiki   2 0 &nbsp;6401 1115 158843725 158843725<br />
green open &nbsp;twitter &nbsp;5 1 11434  &nbsp;0 &nbsp;67155614 &nbsp;33577857<br />
green open &nbsp;twitter2 2 0 &nbsp;2030  &nbsp;0  6125085  6125085<br />
</p>
How many merge operations have the shards for the wiki completed?
<p class="command">
% curl 'localhost:9200/_cat/indices/wiki?pri&v&h=health,index,prirep,docs.count,mt'<br />
health index docs.count mt pri.mt<br />
green &nbsp;wiki    &nbsp;9646 16   16<br />
</p>
How much memory is used per index?
<p class="command">
% curl 'localhost:9200/_cat/indices?v&h=i,tm'<br />
i   tm<br />
wiki &nbsp;8.1gb<br />
test &nbsp;30.5kb<br />
user &nbsp;1.9mb
</p>

<h2>cat master</h2>
master doesn’t have any extra options. It simply displays the master’s node ID, bound IP address, and node name.
<p class="command">
% curl 'localhost:9200/_cat/master?v'<br />
id          &nbsp;ip      &nbsp;node<br />
Ntgn2DcuTjGuXlhKDUD4vA 192.168.56.30 Solarr<br />
</p>
This information is also available via the nodes command, but this is slightly shorter when all you want to do, for example, is verify all nodes agree on the master:
<p class="command">
% pssh -i -h list.of.cluster.hosts curl -s localhost:9200/_cat/master<br />
[1] 19:16:37 [SUCCESS] es3.vm<br />
Ntgn2DcuTjGuXlhKDUD4vA 192.168.56.30 Solarr<br />
[2] 19:16:37 [SUCCESS] es2.vm<br />
Ntgn2DcuTjGuXlhKDUD4vA 192.168.56.30 Solarr<br />
[3] 19:16:37 [SUCCESS] es1.vm<br />
Ntgn2DcuTjGuXlhKDUD4vA 192.168.56.30 Solarr<br />
</p>
<h2>cat nodes</h2> (https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-nodes.html)
The nodes command shows the cluster topology.
<p class="command">
% curl 192.168.56.10:9200/_cat/nodes<br />
SP4H 4727 192.168.56.30 9300 1.5.2 1.8.0_25 72.1gb 35.4 93.9mb 79 239.1mb 0.45 3.4h d m Boneyard<br />
_uhJ 5134 192.168.56.10 9300 1.5.2 1.8.0_25 72.1gb 33.3 93.9mb 85 239.1mb 0.06 3.4h d * Athena<br />
HfDp 4562 192.168.56.20 9300 1.5.2 1.8.0_25 72.2gb 74.5 93.9mb 83 239.1mb 0.12 3.4h d m Zarek<br />
</p>
The first few columns tell you where your nodes live. For sanity it also tells you what version of ES and the JVM each one runs.
<p class="command">
nodeId pid &nbsp;ip      &nbsp;port version jdk<br />
u2PZ  4234 192.168.56.30 9300 1.5.2  1.8.0_25<br />
URzf  5443 192.168.56.10 9300 1.5.2  1.8.0_25<br />
ActN  3806 192.168.56.20 9300 1.5.2  1.8.0_25<br />
</p>
The next few give a picture of your heap, memory, and load.
<p class="command">
diskAvail heapPercent heapMax ramPercent &nbsp;ramMax load<br />
  72.1gb    &nbsp;31.3 &nbsp;93.9mb     81 239.1mb 0.24<br />
  72.1gb    &nbsp;19.6 &nbsp;93.9mb     82 239.1mb 0.05<br />
  72.2gb    &nbsp;64.9 &nbsp;93.9mb     84 239.1mb 0.12<br />
</p>
The last columns provide ancillary information that can often be useful when looking at the cluster as a whole, particularly large ones. How many master-eligible nodes do I have? How many client nodes? It looks like someone restarted a node recently; which one was it?
<p class="command">
uptime data/client master name<br />
 &nbsp;3.5h d      m   &nbsp;Boneyard<br />
 &nbsp;3.5h d      *   &nbsp;Athena<br />
 &nbsp;3.5h d      m   &nbsp;Zarek<br />
Columnsedit<br />
</p>
Below is an exhaustive list of the existing headers that can be passed to nodes?h= to retrieve the relevant details in ordered columns. If no headers are specified, then those marked to Appear by Default will appear. If any header is specified, then the defaults are not used.

Aliases can be used in place of the full header name for brevity. Columns appear in the order that they are listed below unless a different order is specified (e.g., h=pid,id versus h=id,pid).

When specifying headers, the headers are not placed in the output by default. To have the headers appear in the output, use verbose mode (v). The header name will match the supplied value (e.g., pid versus p). For example:
<p class="command">
% curl 192.168.56.10:9200/_cat/nodes?v&h=id,ip,port,v,m<br />
id  ip      &nbsp;port version m<br />
pLSN 192.168.56.30 9300 1.5.2  m<br />
k0zy 192.168.56.10 9300 1.5.2  m<br />
6Tyi 192.168.56.20 9300 1.5.2  *<br />
</p>
<p class="command">
% curl 192.168.56.10:9200/_cat/nodes?h=id,ip,port,v,m<br />
pLSN 192.168.56.30 9300 1.5.2 m<br />
k0zy 192.168.56.10 9300 1.5.2 m<br />
6Tyi 192.168.56.20 9300 1.5.2 *<br />
</p>
<h2>cat pending tasks</h2>
pending_tasks provides the same information as the /_cluster/pending_tasks API in a convenient tabular format.
<p class="command">
% curl 'localhost:9200/_cat/pending_tasks?v'<br />
insertOrder timeInQueue priority source<br />
    1685    855ms HIGH   update-mapping [foo][t]<br />
    1686    843ms HIGH   update-mapping [foo][t]<br />
    1693    753ms HIGH   refresh-mapping [foo][[t]]<br />
    1688    816ms HIGH   update-mapping [foo][t]<br />
    1689    802ms HIGH   update-mapping [foo][t]<br />
    1690    787ms HIGH   update-mapping [foo][t]<br />
    1691    773ms HIGH   update-mapping [foo][t]<br />
</p>

<h2>cat plugins</h2>
he plugins command provides a view per node of running plugins. This information spans nodes.
<p class="command">
% curl 'localhost:9200/_cat/plugins?v'<br />
name  &nbsp;component    version    &nbsp;type isolation url<br />
Abraxas cloud-azure   2.1.0-SNAPSHOT j  &nbsp;x<br />
Abraxas lang-groovy   2.0.0     &nbsp;j  &nbsp;x<br />
Abraxas lang-javascript 2.0.0-SNAPSHOT j  &nbsp;x<br />
Abraxas marvel     &nbsp;NA       j/s &nbsp;x     /_plugin/marvel/<br />
Abraxas lang-python   2.0.0-SNAPSHOT j  &nbsp;x<br />
Abraxas inquisitor   &nbsp;NA       s       &nbsp;/_plugin/inquisitor/<br />
Abraxas kopf      &nbsp;0.5.2     &nbsp;s       &nbsp;/_plugin/kopf/<br />
Abraxas segmentspy   &nbsp;NA       s       &nbsp;/_plugin/segmentspy/<br />
</p>
We can tell quickly how many plugins per node we have and which versions.

<h2>cat recovery</h2>
The recovery command is a view of index shard recoveries, both on-going and previously completed. It is a more compact view of the JSON recovery API.

A recovery event occurs anytime an index shard moves to a different node in the cluster. This can happen during a snapshot recovery, a change in replication level, node failure, or on node startup. This last type is called a local gateway recovery and is the normal way for shards to be loaded from disk when a node starts up.

As an example, here is what the recovery state of a cluster may look like when there are no shards in transit from one node to another:
<p class="command">
> curl -XGET 'localhost:9200/_cat/recovery?v'<br />
index shard time type  &nbsp;stage source target files percent bytes   percent<br />
wiki &nbsp;0   73  gateway done &nbsp;hostA &nbsp;hostA &nbsp;36  &nbsp;100.0% &nbsp;24982806 100.0%<br />
wiki &nbsp;1   245 &nbsp;gateway done &nbsp;hostA &nbsp;hostA &nbsp;33  &nbsp;100.0% &nbsp;24501912 100.0%<br />
wiki &nbsp;2   230 &nbsp;gateway done &nbsp;hostA &nbsp;hostA &nbsp;36  &nbsp;100.0% &nbsp;30267222 100.0%<br />
</p>
In the above case, the source and target nodes are the same because the recovery type was gateway, i.e. they were read from local storage on node start.

Now let’s see what a live recovery looks like. By increasing the replica count of our index and bringing another node online to host the replicas, we can see what a live shard recovery looks like.
<p class="command">
> curl -XPUT 'localhost:9200/wiki/_settings' -d'{"number_of_replicas":1}'<br />
{"acknowledged":true}<br />
</p>
<p class="command">
> curl -XGET 'localhost:9200/_cat/recovery?v'<br />
index shard time type  &nbsp;stage source target files percent bytes  &nbsp;percent<br />
wiki &nbsp;0   1252 gateway done &nbsp;hostA &nbsp;hostA &nbsp;4   100.0% &nbsp;23638870 100.0%<br />
wiki &nbsp;0   1672 replica index hostA &nbsp;hostB &nbsp;4   75.0%  23638870 48.8%<br />
wiki &nbsp;1   1698 replica index hostA &nbsp;hostB &nbsp;4   75.0%  23348540 49.4%<br />
wiki &nbsp;1   4812 gateway done &nbsp;hostA &nbsp;hostA &nbsp;33  &nbsp;100.0% &nbsp;24501912 100.0%<br />
wiki &nbsp;2   1689 replica index hostA &nbsp;hostB &nbsp;4   75.0%  28681851 40.2%<br />
wiki &nbsp;2   5317 gateway done &nbsp;hostA &nbsp;hostA &nbsp;36  &nbsp;100.0% &nbsp;30267222 100.0%<br />
</p>
We can see in the above listing that our 3 initial shards are in various stages of being replicated from one node to another. Notice that the recovery type is shown as replica. The files and bytes copied are real-time measurements.

Finally, let’s see what a snapshot recovery looks like. Assuming I have previously made a backup of my index, I can restore it using the snapshot and restore API.
<p class="command">
> curl -XPOST 'localhost:9200/_snapshot/imdb/snapshot_2/_restore'<br />
{"acknowledged":true}<br />
</p>
<p class="command">
> curl -XGET 'localhost:9200/_cat/recovery?v'<br />
index shard time type   stage repository snapshot files percent bytes percent<br />
imdb &nbsp;0   1978 snapshot done &nbsp;imdb    snap_1  79  &nbsp;8.0%  &nbsp;12086 9.0%<br />
imdb &nbsp;1   2790 snapshot index imdb    snap_1  88  &nbsp;7.7%  &nbsp;11025 8.1%<br />
imdb &nbsp;2   2790 snapshot index imdb    snap_1  85  &nbsp;0.0%  &nbsp;12072 0.0%<br />
imdb &nbsp;3   2796 snapshot index imdb    snap_1  85  &nbsp;2.4%  &nbsp;12048 7.2%<br />
imdb &nbsp;4   819 &nbsp;snapshot init &nbsp;imdb    snap_1  0   0.0%  &nbsp;0   0.0%<br />
</p>
<h2>cat thread pool</h2> (https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-thread-pool.html)
The thread_pool command shows cluster wide thread pool statistics per node. By default the active, queue and rejected statistics are returned for the bulk, index and search thread pools.
<p class="command">
% curl 192.168.56.10:9200/_cat/thread_pool<br />
host1 192.168.1.35 0 0 0 0 0 0 0 0 0<br />
host2 192.168.1.36 0 0 0 0 0 0 0 0 0<br />
</p>
The first two columns contain the host and ip of a node.
<p class="command">
host   &nbsp;ip<br />
host1 192.168.1.35<br />
host2 192.168.1.36<br />
</p>
The next three columns show the active queue and rejected statistics for the bulk thread pool.
<p class="command">
bulk.active bulk.queue bulk.rejected<br />
     &nbsp;0     &nbsp;0       0<br />
</p>
The remaining columns show the active queue and rejected statistics of the index and search thread pool respectively.

Also other statistics of different thread pools can be retrieved by using the h (header) parameter.
<p class="command">
% curl 'localhost:9200/_cat/thread_pool?v&h=id,host,suggest.active,suggest.rejected,suggest.completed'<br />
host   &nbsp;suggest.active suggest.rejected suggest.completed<br />
host1         &nbsp;0        &nbsp;0         0<br />
host2         &nbsp;0        &nbsp;0         0<br />
</p>
Here the host columns and the active, rejected and completed suggest thread pool statistic are displayed. The suggest thread pool won’t be displayed by default, so you always need to be specific about what statistic you want to display.

<h2>cat shards</h2>
The shards command is the detailed view of what nodes contain which shards. It will tell you if it’s a primary or replica, the number of docs, the bytes it takes on disk, and the node where it’s located.

Here we see a single index, with three primary shards and no replicas:
<p class="command">
% curl 192.168.56.20:9200/_cat/shards<br />
wiki1 0 p STARTED 3014 31.1mb 192.168.56.10 Stiletto<br />
wiki1 1 p STARTED 3013 29.6mb 192.168.56.30 Frankie Raye<br />
wiki1 2 p STARTED 3973 38.1mb 192.168.56.20 Commander Kraken<br />
</p>
	
	<h2>index pattern</h2>
	If you have many shards, you may wish to limit which indices show up in the output. You can always do this with grep, but you can save some bandwidth by supplying an index pattern to the end.
<p class="command">
	% curl 192.168.56.20:9200/_cat/shards/wiki2<br />
	wiki2 0 p STARTED 197 3.2mb 192.168.56.10 Stiletto<br />
	wiki2 1 p STARTED 205 5.9mb 192.168.56.30 Frankie Raye<br />
	wiki2 2 p STARTED 275 7.8mb 192.168.56.20 Commander Kraken<br />
</p>

	<h2>Realocating</h2>
	Let’s say you’ve checked your health and you see two relocating shards. Where are they from and where are they going?
<p class="command">
	% curl 192.168.56.10:9200/_cat/health<br />
	1384315316 20:01:56 foo green 3 3 12 6 2 0 0<br />
	% curl 192.168.56.10:9200/_cat/shards | fgrep RELO<br />
	wiki1 0 r RELOCATING 3014 31.1mb 192.168.56.20 Commander Kraken -> 192.168.56.30 Frankie Raye<br />
	wiki1 1 r RELOCATING 3013 29.6mb 192.168.56.10 Stiletto -> 192.168.56.30 Frankie Raye<br />
</p>

	<h2>shard states</h2>
	Before a shard can be used, it goes through an INITIALIZING state. shards can show you which ones.
<p class="command">
% curl -XPUT 192.168.56.20:9200/_settings -d'{"number_of_replicas":1}'<br />
{"acknowledged":true}<br />
</p>
<p class="command">
% curl 192.168.56.20:9200/_cat/shards<br />
wiki1 0 p STARTED   &nbsp;3014 31.1mb 192.168.56.10 Stiletto<br />
wiki1 0 r INITIALIZING  &nbsp;0 14.3mb 192.168.56.30 Frankie Raye<br />
wiki1 1 p STARTED   &nbsp;3013 29.6mb 192.168.56.30 Frankie Raye<br />
wiki1 1 r INITIALIZING  &nbsp;0 13.1mb 192.168.56.20 Commander Kraken<br />
wiki1 2 r INITIALIZING  &nbsp;0  14mb 192.168.56.10 Stiletto<br />
wiki1 2 p STARTED   &nbsp;3973 38.1mb 192.168.56.20 Commander Kraken<br />
</p>
If a shard cannot be assigned, for example you’ve overallocated the number of replicas for the number of nodes in the cluster, they will remain UNASSIGNED.
<p class="command">
% curl -XPUT 192.168.56.20:9200/_settings -d'{"number_of_replicas":3}'<br />
% curl 192.168.56.20:9200/_cat/health<br />
1384316325 20:18:45 foo yellow 3 3 9 3 0 0 3<br />
</p>
<p class="command">
% curl 192.168.56.20:9200/_cat/shards<br />
wiki1 0 p STARTED  &nbsp;3014 31.1mb 192.168.56.10 Stiletto<br />
wiki1 0 r STARTED  &nbsp;3014 31.1mb 192.168.56.30 Frankie Raye<br />
wiki1 0 r STARTED  &nbsp;3014 31.1mb 192.168.56.20 Commander Kraken<br />
wiki1 0 r UNASSIGNED<br />
wiki1 1 r STARTED  &nbsp;3013 29.6mb 192.168.56.10 Stiletto<br />
wiki1 1 p STARTED  &nbsp;3013 29.6mb 192.168.56.30 Frankie Raye<br />
wiki1 1 r STARTED  &nbsp;3013 29.6mb 192.168.56.20 Commander Kraken<br />
wiki1 1 r UNASSIGNED<br />
wiki1 2 r STARTED  &nbsp;3973 38.1mb 192.168.56.10 Stiletto<br />
wiki1 2 r STARTED  &nbsp;3973 38.1mb 192.168.56.30 Frankie Raye<br />
wiki1 2 p STARTED  &nbsp;3973 38.1mb 192.168.56.20 Commander Kraken<br />
wiki1 2 r UNASSIGNED<br />
</p>

<h2>cat segments</h2>
The segments command provides low level information about the segments in the shards of an index. It provides information similar to the _segments endpoint.
<p class="command">
% curl 'http://localhost:9200/_cat/segments?v'<br />
index shard prirep ip      &nbsp;segment generation docs.count [...]<br />
test &nbsp;4   p   &nbsp;192.168.2.105 _0        0     &nbsp;1<br />
test1 2   p   &nbsp;192.168.2.105 _0        0     &nbsp;1<br />
test1 3   p   &nbsp;192.168.2.105 _2        2     &nbsp;1<br />
[...] docs.deleted &nbsp;size size.memory committed searchable version compound<br />
         0 2.9kb    &nbsp;7818 false   true    4.10.2 &nbsp;true<br />
         0 2.9kb    &nbsp;7818 false   true    4.10.2 &nbsp;true<br />
         0 2.9kb    &nbsp;7818 false   true    4.10.2 &nbsp;true<br />
</p>
The output shows information about index names and shard numbers in the first two columns.

If you only want to get information about segments in one particular index, you can add the index name in the URL, for example /_cat/segments/test. Also, several indexes can be queried like /_cat/segments/test,test1

The following columns provide additional monitoring information:

<h2>prirep</h2>
Whether this segment belongs to a primary or replica shard.
<h2>ip</h2>
The ip address of the segments shard.
<h2>segment</h2>
A segment name, derived from the segment generation. The name is internally used to generate the file names in the directory of the shard this segment belongs to.
<h2>generation</h2>
The generation number is incremented with each segment that is written. The name of the segment is derived from this generation number.
<h2>docs.count</h2>
The number of non-deleted documents that are stored in this segment.
<h2>docs.deleted</h2>
The number of deleted documents that are stored in this segment. It is perfectly fine if this number is greater than 0, space is going to be reclaimed when this segment gets merged.
<h2>size</h2>
The amount of disk space that this segment uses.
<h2>size.memory</h2>
Segments store some data into memory in order to be searchable efficiently. This column shows the number of bytes in memory that are used.
<h2>committed</h2>
Whether the segment has been sync’ed on disk. Segments that are committed would survive a hard reboot. No need to worry in case of false, the data from uncommitted segments is also stored in the transaction log so that Elasticsearch is able to replay changes on the next start.
<h2>searchable</h2>
True if the segment is searchable. A value of false would most likely mean that the segment has been written to disk but no refresh occurred since then to make it searchable.
<h2>version</h2>
The version of Lucene that has been used to write this segment.
<h2>compound</h2>
Whether the segment is stored in a compound file. When true, this means that Lucene merged all files from the segment in a single one in order to save file descriptors.

 </body>
</html>